# 多餘程式碼分析報告

## 1. 重複的 Optimism 鏈選擇邏輯 ⚠️ 高優先級

### 位置
- **`executePresetSetup()`** (約 1993-2237 行)
- **`selectOptimismChainInSettings()`** (約 3400-3598 行)

### 問題
兩個函數中都有幾乎完全相同的 Optimism 鏈選擇邏輯，包括：
- 三種查找方法（TokenImage、span 文字、div）
- 相同的驗證邏輯
- 相同的錯誤處理

### 建議
將鏈選擇邏輯提取為獨立函數，兩個地方都調用它。可以節省約 **200+ 行**重複代碼。

---

## 2. 重複的 Save 按鈕查找邏輯 ⚠️ 高優先級

### 位置
- **`executePresetSetup()`** (約 2347-2424 行)
- **`applySlippageAndPriority()`** (約 3824-3895 行)

### 問題
兩個函數中都有完全相同的 Save 按鈕查找和點擊邏輯：
- 方法1：通過文字 "Save" 和 `bg-genius-pink` 類查找
- 方法2：通過選擇器 `button.bg-genius-pink` 查找
- 相同的重試機制（最多 5 次）
- 相同的錯誤處理

### 建議
提取為 `findAndClickSaveButton()` 函數。可以節省約 **70+ 行**重複代碼。

---

## 3. 重複的關閉按鈕查找邏輯 ⚠️ 中優先級

### 位置
- **`findCloseButton()`** (約 920-927 行) - 已存在的函數
- **`executePresetSetup()`** (約 2537-2647 行) - 重複實現

### 問題
`executePresetSetup()` 中重新實現了關閉按鈕的查找邏輯，但沒有使用已存在的 `findCloseButton()` 函數。雖然實現方式略有不同（更詳細），但可以改進為使用現有函數並增強它。

### 建議
在 `executePresetSetup()` 中使用 `findCloseButton()`，如果需要更詳細的查找，可以增強 `findCloseButton()` 函數。可以節省約 **110+ 行**重複代碼。

---

## 4. 已棄用但未移除的配置項 ⚠️ 低優先級

### 位置
- **CONFIG** (約 129 行)

### 問題
```javascript
waitBeforeConfirm: 3000,  // 點擊 Confirm 前的緩衝等待（已棄用，改用 waitForQuoteReady）
```
這個配置項已標記為棄用，但仍在配置對象中，且沒有被使用。

### 建議
直接移除這個配置項。可以節省 **1 行**代碼，並減少混淆。

---

## 5. 未使用的變數和過度複雜的 fetch 攔截 ⚠️ 中優先級

### 位置
- **`verifySwapSuccess()`** (約 3952-4025 行)

### 問題
1. **`hasNetworkError` 變數**：被設置但從未真正使用（註釋說「不影響 SWAP 判斷」）
2. **複雜的 fetch 攔截邏輯**：包含大量代碼來攔截和處理 API 錯誤，但：
   - 註釋明確說明「不影響 SWAP 成功/失敗判斷」
   - 只是記錄日誌，不影響實際邏輯
   - 函數本身已被標記為「備用驗證機制」

### 建議
由於 `verifySwapSuccess()` 現在是備用機制，且主要邏輯已改為 `verifySwapByTokenComparison()`，可以：
1. 簡化或移除 fetch 攔截邏輯（如果不需要詳細的錯誤日誌）
2. 移除未使用的 `hasNetworkError` 變數

可以節省約 **70+ 行**代碼。

---

## 6. 重複的餘額驗證邏輯 ⚠️ 中優先級

### 位置
- **`verifySwapSuccess()`** 函數內多處（約 4168-4380 行）

### 問題
在 `verifySwapSuccess()` 函數中，有至少 **3 處**幾乎完全相同的餘額驗證邏輯：
1. 備用判斷（約 4168-4213 行）
2. 主要驗證（約 4217-4336 行）
3. 幣種未變化時的備用驗證（約 4344-4380 行）

這些邏輯都做相同的事情：
- 讀取交易後餘額
- 計算餘額變化
- 驗證發送幣減少和接收幣增加
- 使用相同的閾值（90% 或 95%）

### 建議
提取為 `verifyBalanceChange()` 輔助函數。可以節省約 **150+ 行**重複代碼。

---

## 7. 過度複雜的 `verifySwapSuccess()` 函數 ⚠️ 低優先級

### 位置
- **`verifySwapSuccess()`** (約 3938-4501 行，共 **563 行**)

### 問題
1. 函數註釋明確說明：「此函數現在主要作為備用驗證機制，主要判斷邏輯已改為 `verifySwapByTokenComparison`」
2. 函數非常長（563 行），包含大量複雜邏輯
3. 但實際上在 `executeSwapLoop()` 中**沒有被調用**（只使用了 `verifySwapByTokenComparison()`）

### 建議
如果確認不再需要這個備用機制，可以：
- 完全移除這個函數（節省 **563 行**）
- 或者大幅簡化它，只保留最基本的驗證邏輯

**注意**：需要確認這個函數是否真的不再被使用。

---

## 8. 重複的 Buy/Sell 按鈕點擊邏輯 ⚠️ 低優先級

### 位置
- **`clickBuyOrSellButton()`** (約 1891-1957 行) - 已存在的函數
- **`executePresetSetup()`** 和 **`applySlippageAndPriority()`** 中都有調用

### 狀態
這個已經被正確提取為函數，沒有重複。✅

---

## 9. 重複的 Slippage/Priority 設定邏輯 ⚠️ 低優先級

### 位置
- **`executePresetSetup()`** (約 2263-2345 行)
- **`applySlippageAndPriority()`** → **`applySlippageAndPriority()`** (約 3670-3812 行)

### 問題
兩個地方都有設定 Slippage 和 Priority 的邏輯，雖然流程略有不同（一個是初始設定，一個是動態調整），但核心的設定和驗證邏輯是重複的。

### 建議
可以提取為 `setSlippageAndPriority(slippage, priority, mode)` 函數，其中 `mode` 可以是 'Buy' 或 'Sell'。可以節省約 **100+ 行**重複代碼。

---

## 總結

### 可以立即優化的項目（高優先級）
1. **Optimism 鏈選擇邏輯重複** - 節省 ~200 行
2. **Save 按鈕查找邏輯重複** - 節省 ~70 行
3. **關閉按鈕查找邏輯重複** - 節省 ~110 行

**小計：約 380 行**

### 可以考慮優化的項目（中優先級）
4. **餘額驗證邏輯重複** - 節省 ~150 行
5. **未使用的 fetch 攔截邏輯** - 節省 ~70 行

**小計：約 220 行**

### 需要確認後優化的項目（低優先級）
6. **已棄用的配置項** - 節省 1 行
7. **`verifySwapSuccess()` 函數** - 如果確認不再使用，可節省 563 行
8. **Slippage/Priority 設定邏輯** - 節省 ~100 行

**小計：約 664 行**

### 總計
如果全部優化，可以節省約 **1,264 行**代碼（約佔總代碼量的 24%）。

---

## 建議的優化順序

1. **第一步**：提取 Save 按鈕和關閉按鈕的查找邏輯（簡單、低風險）
2. **第二步**：提取 Optimism 鏈選擇邏輯（中等複雜度）
3. **第三步**：提取餘額驗證邏輯（需要仔細測試）
4. **第四步**：確認 `verifySwapSuccess()` 是否仍需要，如果不需要則移除
5. **第五步**：簡化或移除 fetch 攔截邏輯

---

## 注意事項

⚠️ **在進行任何優化前，請確保：**
1. 充分測試現有功能
2. 確認所有函數的調用關係
3. 保留必要的錯誤處理和日誌記錄
4. 逐步進行，每次優化後都要測試
